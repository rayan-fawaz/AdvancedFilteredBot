import requests
import asyncio
import logging
import json
import os
from datetime import datetime, timezone, timedelta

# Telegram API
BOT_TOKEN = "7718667713:AAFbbdQXw7UAG2ey_WBFXeeJjYiWB3qSS3k"
GROUP_ID = "-1002325577117"

# Pump.Fun API
API_URL = "https://frontend-api-v3.pump.fun/coins/for-you?offset=0&limit=50&includeNsfw=false"

# Helius API
HELIUS_API_KEY = "d2eb41e9-0474-45d9-8c53-f487ac8fdd96"
HELIUS_RPC_URL = f"https://mainnet.helius-rpc.com/?api-key={HELIUS_API_KEY}"

# Market Cap Range
MIN_MARKET_CAP = 8000
MAX_MARKET_CAP = 22000

# Logging Configuration
logging.basicConfig(level=logging.INFO)


async def fetch_featured_coins():
    """Fetch featured coins from Pump.Fun API."""
    try:
        response = requests.get(API_URL)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logging.error(f"Error fetching featured coins: {e}")
        return []


async def send_telegram_message(message):
    """Send a message to the Telegram group."""
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": GROUP_ID,
        "text": message,
        "parse_mode": "HTML",
        "disable_web_page_preview": True
    }
    try:
        response = requests.post(url, json=payload)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to send message: {e}")


def get_dex_data(token_mint):
    """Get volume and price change data from DexScreener and Moralis APIs."""
    try:
        # Get DexScreener data
        dex_response = requests.get(
            f"https://api.dexscreener.com/latest/dex/tokens/{token_mint}",
            timeout=10)

        # Get Moralis pair data
        moralis_url = f"https://solana-gateway.moralis.io/token/mainnet/{token_mint}/pairs"
        moralis_headers = {
            "Accept":
            "application/json",
            "X-API-Key":
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub25jZSI6IjA1ZWQ1M2UxLTA4YTUtNGY1Yy1hMmZmLTg0ODhiYzVmNzNhNSIsIm9yZ0lkIjoiNDMzNTI0IiwidXNlcklkIjoiNDQ1OTUxIiwidHlwZUlkIjoiNDEyNWI4NGMtMjM4Ni00OTZhLTgxZWQtYzdhNWVjNjNmYWNhIiwidHlwZSI6IlBST0pFQ1QiLCJpYXQiOjE3NDA0OTg3MTEsImV4cCI6NDg5NjI1ODcxMX0.X6JXdTuoB4Vx1-dhhl_ya6fGpUwxcY-Urp_s0KFppac"  # Replace with your Moralis API key
        }
        moralis_response = requests.get(moralis_url,
                                        headers=moralis_headers,
                                        timeout=10)

        pair_address = None
        if moralis_response.ok:
            pair_data = moralis_response.json()
            logging.info(f"Moralis response: {pair_data}")
            if isinstance(pair_data, dict) and "pairs" in pair_data:
                pairs = pair_data["pairs"]
                if pairs and isinstance(pairs, list) and len(pairs) > 0:
                    pair_address = pairs[0].get("pairAddress")
                    if pair_address:
                        print(f"Found pair address: {pair_address}")
                        logging.info(
                            f"Found pair address for {token_mint}: {pair_address}"
                        )
                    else:
                        print("No pair address found in pairs data")
                else:
                    print("No pairs found in response")
            else:
                print("Invalid response format from Moralis")

        # Get OHLCV data from Moralis
        # Calculate date range (current date and one month ago)
        current_date = datetime.now(timezone.utc).strftime('%Y-%m-%d')
        one_month_ago = (datetime.now(timezone.utc) -
                         timedelta(days=30)).strftime('%Y-%m-%d')

        ohlcv_url = f"https://solana-gateway.moralis.io/token/mainnet/pairs/{pair_address}/ohlcv?timeframe=1M&currency=usd&fromDate={one_month_ago}&toDate={current_date}&limit=10"
        ohlcv_headers = {
            "Accept":
            "application/json",
            "X-API-Key":
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub25jZSI6ImFlY2YxZDIxLWM3MDgtNDQ4OS04NWM4LWNlODNlZGMwYjE2NSIsIm9yZ0lkIjoiNDMyNTE2IiwidXNlcklkIjoiNDQ0OTA3IiwidHlwZUlkIjoiZmVhZGI3MTMtMjg4OC00NDM4LThiNDYtZTUwNzlmNGUxOTg0IiwidHlwZSI6IlBST0pFQ1QiLCJpYXQiOjE3NDAwMTIxMDIsImV4cCI6NDg5NTc3MjEwMn0.v6355uA7kh8iw-rJ1aGfeucbYUPZRDaRXnUiUXetC44"
        }
        ohlcv_response = requests.get(ohlcv_url, headers=ohlcv_headers)
        ohlcv_data = ohlcv_response.json()
        print(f"OHLCV response: {ohlcv_data}")

        ath_price = None
        if 'result' in ohlcv_data and len(ohlcv_data['result']) > 0:
            high = ohlcv_data['result'][0].get('high')
            if high:
                ath_price = round(high * 1000000000)
                print(f"High value: {round(high)}")
                print(f"ATH Price (rounded): {ath_price}")

        data = dex_response.json()
        if 'pairs' in data and len(data['pairs']) > 0:
            pair = data['pairs'][0]
            return {
                'volume_24h':
                float(pair.get('volume', {}).get('h24', 0)),
                'volume_6h':
                float(pair.get('volume', {}).get('h6', 0)),
                'volume_1h':
                float(pair.get('volume', {}).get('h1', 0)),
                'volume_5m':
                float(pair.get('volume', {}).get('m5', 0)),
                'price_change_24h':
                float(pair.get('priceChange', {}).get('h24', 0)),
                'price_change_6h':
                float(pair.get('priceChange', {}).get('h6', 0)),
                'price_change_1h':
                float(pair.get('priceChange', {}).get('h1', 0)),
                'price_change_5m':
                float(pair.get('priceChange', {}).get('m5', 0)),
                'pair_address':
                pair_address,
                'ath_price':
                ath_price
            }
        return None
    except Exception as e:
        logging.error(f"Error fetching DEX data: {e}")
        return None


def fetch_token_holders(token_mint):
    """Fetch the holder count and distribution for a token."""
    try:
        # Get holder distribution from Helius first
        payload = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "getTokenLargestAccounts",
            "params": [token_mint]
        }
        response = requests.post(HELIUS_RPC_URL, json=payload)
        response.raise_for_status()
        holders = response.json().get("result", {}).get("value", [])

        if not holders or len(holders) < 2:
            return None

        # First get total supply including bonding curve
        total_supply = sum(float(holder["amount"]) for holder in holders)

        if total_supply == 0:
            return None

        # Skip the first holder (bonding curve) and use the rest
        real_holders = holders[1:]

        # Calculate percentages using total supply with real holders
        top_5_percentages = [
            float(holder["amount"]) / total_supply * 100
            for holder in real_holders[:5]
        ]

        # Check if any holder has more than 5%
        if any(percentage > 5.0 for percentage in top_5_percentages):
            return None

        # Only make Birdeye request if no holder has more than 5%
        birdeye_url = f"https://public-api.birdeye.so/defi/v3/token/trade-data/single?address={token_mint}"
        headers = {
            "accept": "application/json",
            "x-chain": "solana",
            "X-API-KEY": "114f18a5eb5e4d51a9ac7c6100dfe756"
        }

        birdeye_response = requests.get(birdeye_url, headers=headers)
        birdeye_response.raise_for_status()

        data = birdeye_response.json()
        total_holders = data.get('data', {}).get('holder', 0)
        buy_1h = data.get('data', {}).get('buy_1h', 0)
        sell_1h = data.get('data', {}).get('sell_1h', 0)
        trade_1h = data.get('data', {}).get('trade_1h', 0)
        unique_wallet_1h = data.get('data', {}).get('unique_wallet_1h', 0)
        unique_wallet_24h = data.get('data', {}).get('unique_wallet_24h', 0)

        if total_holders < 2:
            return None

        # Get holder distribution from Helius
        payload = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "getTokenLargestAccounts",
            "params": [token_mint]
        }
        response = requests.post(HELIUS_RPC_URL, json=payload)
        response.raise_for_status()
        holders = response.json().get("result", {}).get("value", [])

        if not holders or len(holders) < 2:
            return None

        # First get total supply including bonding curve
        total_supply = sum(float(holder["amount"]) for holder in holders)

        if total_supply == 0:
            return None

        # Skip the first holder (bonding curve) and use the rest
        real_holders = holders[1:]

        # Calculate percentages using total supply with real holders
        top_10_percentage = sum(
            float(holder["amount"])
            for holder in real_holders[:10]) / total_supply * 100
        top_20_percentage = sum(
            float(holder["amount"])
            for holder in real_holders[:20]) / total_supply * 100
        top_5 = [
            float(holder["amount"]) / total_supply * 100
            for holder in real_holders[:5]
        ]

        return {
            "total_holders": total_holders,
            "top_5_percentages": top_5,
            "top_10_percentage": top_10_percentage,
            "top_20_percentage": top_20_percentage,
            "buy_1h": buy_1h,
            "sell_1h": sell_1h,
            "trade_1h": trade_1h,
            "unique_wallet_1h": unique_wallet_1h,
            "unique_wallet_24h": unique_wallet_24h
        }
    except requests.exceptions.RequestException as e:
        logging.error(f"Error fetching holders: {e}")
        return None


def format_holders_message(holders_info):
    """Format holders information for the message."""
    top_5 = " | ".join(f"{percent:.2f}"
                       for percent in holders_info["top_5_percentages"])
    makers_line = '├' if holders_info.get(
        'unique_wallet_1h') != holders_info.get('unique_wallet_24h') else '└'
    makers_24h = f'└─ <b>24h Makers:</b> {holders_info.get("unique_wallet_24h", 0)}\n' if holders_info.get(
        'unique_wallet_1h') != holders_info.get('unique_wallet_24h') else ''

    return (
        f"👥 <b>Holders</b>\n"
        f"├─ <b>Total Holders:</b> {holders_info.get('total_holders', 0):,}\n"
        f"├─ <b>TH 10:</b> {holders_info['top_10_percentage']:.2f}%\n"
        f"├─ <b>TH 20:</b> {holders_info['top_20_percentage']:.2f}%\n"
        f"└─ <b>TH:</b> {top_5}\n\n"
        f"🏧 <b>Trades 1h</b>\n"
        f"└─ <b>🅣</b> {holders_info.get('trade_1h', 0)} | "
        f"<b>🅑</b> {holders_info.get('buy_1h', 0)} | "
        f"<b>🅢</b> {holders_info.get('sell_1h', 0)}\n\n"
        f"🧑‍💻 <b>Makers</b>\n"
        f"{makers_line}─ <b>1h Makers:</b> {holders_info.get('unique_wallet_1h', 0)}\n"
        f"{makers_24h}\n")


def format_coin_message(coin, holders_info, dex_data):
    """Format coin information into a readable message."""
    mint_address = coin["mint"]
    pumpfun_link = f"https://pump.fun/coin/{mint_address}"
    bullx_link = f"https://neo.bullx.io/terminal?chainId=1399811149&address={mint_address}&r=YEGC2RLRAUE&l=en"

    # Get bundle info
    trench_data = get_trench_data(mint_address)
    bundle_info = ""
    if trench_data:
        bundle_info = (
            f"📚 <b>Bundle Info</b>\n"
            f"├─ Total Bundles: {trench_data['total_bundles']:,}\n"
            f"└─ Held Bundles: {trench_data['total_holding_percentage']:.2f}%\n\n"
        )

    volume_text = ""
    price_text = ""

    if dex_data:
        # Define periods in order from lowest to highest
        period_order = ['5m', '1h', '6h', '24h']
        price_changes = {
            '24h': dex_data['price_change_24h'],
            '6h': dex_data['price_change_6h'],
            '1h': dex_data['price_change_1h'],
            '5m': dex_data['price_change_5m']
        }

        # Group by unique values and keep lowest period
        unique_changes = {}
        for period in period_order:
            change = price_changes[period]
            if change not in unique_changes:
                unique_changes[change] = period

        # Format the price text
        price_parts = []
        for change, period in unique_changes.items():
            price_parts.append(f"{period}: {change:+.0f}%")

        price_text = f"📈 <b>Price Changes:</b>\n{' | '.join(price_parts)}\n\n"

        # Define periods in order from lowest to highest
        period_order = ['5m', '1h', '6h', '24h']
        volumes = {
            '24h': dex_data['volume_24h'],
            '6h': dex_data['volume_6h'],
            '1h': dex_data['volume_1h'],
            '5m': dex_data['volume_5m']
        }

        # Group by unique values and keep lowest period
        unique_volumes = {}
        for period in period_order:
            vol = volumes[period]
            if vol not in unique_volumes:
                unique_volumes[vol] = period

        # Format the volume text
        volume_parts = []
        num_volumes = len(unique_volumes)
        for i, (vol, period) in enumerate(unique_volumes.items()):
            marker = '├─' if i < num_volumes - 1 else '└─'
            volume_parts.append(f"{marker} {period}: ${vol:,.2f}")

        volume_text = f"📊 <b>Volume:</b>\n" + "\n".join(volume_parts) + "\n\n"

        # Handle ATH price calculation
        market_cap = float(coin.get('usd_market_cap', 0))
        ath_price = market_cap

        if dex_data and isinstance(dex_data, dict):
            ath_from_dex = dex_data.get('ath_price')
            if ath_from_dex is not None:
                try:
                    ath_from_dex = float(ath_from_dex)
                    ath_price = max(ath_from_dex, market_cap)
                except (ValueError, TypeError):
                    pass

        ath_text = f"📈 <b>ATH: ${int(ath_price):,}</b>\n\n"

    # Check if DEX is paid using orders API
    try:
        dex_response = requests.get(
            f"https://api.dexscreener.com/orders/v1/solana/{mint_address}",
            headers={},
            timeout=5)
        dex_data_orders = dex_response.json()
        dex_paid = dex_data_orders.get(
            "status") == "approved" if dex_data_orders else False
    except:
        dex_paid = False

    dex_status = "🟢" if dex_paid else "🔴"

    return (f"🔹 <b>{coin['name']}</b> ({coin['symbol']})\n"
            f"💰 <b>Market Cap: </b>${coin['usd_market_cap']:,.2f}\n"
            f"🎯 <b>DEX Paid:</b> {dex_status}\n"
            f"{price_text}"
            f"{volume_text}"
            f"{ath_text}"
            f"{format_holders_message(holders_info)}"
            f"{bundle_info}"
            f"🔗 <a href='{coin['telegram']}'>TG</a> | "
            f"🖥 <a href='{coin.get('website', '#')}'>WEB</a> | "
            f"🐦 <a href='{coin.get('twitter', '#')}'>X</a>\n\n"
            f"💊 <a href='{pumpfun_link}'>PF</a> | "
            f"📊 <a href='{bullx_link}'>NEO</a>\n\n"
            f"🆔 Mint: <code>{mint_address}</code>\n"
            f"——————————————————————————————\n")


async def scan_coins():
    """Continuously scan Pump.Fun API for new coins."""
    seen_mints = {}
    while True:
        coins = await fetch_featured_coins()
        new_coins = []

        for coin in coins:
            mint = coin.get("mint")
            market_cap = coin.get("usd_market_cap")

            if mint and MIN_MARKET_CAP <= market_cap <= MAX_MARKET_CAP and coin.get("telegram"):
                if mint not in seen_mints:
                    holders_info = fetch_token_holders(mint)
                    if not holders_info:
                        continue

                    dex_data = get_dex_data(mint)
                    if not dex_data:
                        continue

                    # Skip if any holder has more than 5%
                    large_holder_exists = any(
                        percentage > 5.0
                        for percentage in holders_info["top_5_percentages"])
                    if large_holder_exists:
                        continue

                    # Skip if top 5 holders have same rounded percentages
                    rounded_percentages = [
                        round(p, 1) for p in holders_info["top_5_percentages"]
                    ]
                    if len(set(rounded_percentages)) < len(rounded_percentages):
                        continue

                    # Check if any bump bots have traded other tokens
                    if check_bump_bot_history(mint):
                        continue

                    new_coins.append((coin, holders_info, dex_data))
                    seen_mints[mint] = market_cap

        if new_coins:
            message = "🚀 <b>NEW COINS ALERT!</b> 🚀\n\n" + "\n".join(
                format_coin_message(coin, holders_info, dex_data)
                for coin, holders_info, dex_data in new_coins)
            await send_telegram_message(message)

        logging.info(f"Checked: {len(new_coins)} new coins")
        await asyncio.sleep(15)


def get_trench_data(mint_address):
    """Fetch bundle data from Trench API."""
    try:
        response = requests.get(f"https://trench.bot/api/bundle/bundle_advanced/{mint_address}", timeout=30)
        response.raise_for_status()
        data = response.json()

        if isinstance(data, dict):
            total_bundles = data.get('total_bundles', 0)
            total_holding_percentage = data.get('total_holding_percentage', 0)
            return {
                'total_bundles': total_bundles,
                'total_holding_percentage': total_holding_percentage
            }
        logging.warning(f"Invalid Trench data format for {mint_address}")
        return None
    except requests.exceptions.RequestException as e:
        logging.error(f"Error fetching Trench data for {mint_address}: {e}")
        return None

async def scan_coins_alt():
    """Scan coins with alternative filtering criteria."""
    seen_mints = {}
    while True:
        coins = await fetch_featured_coins()
        new_coins = []

        for coin in coins:
            mint = coin.get("mint")
            market_cap = coin.get("usd_market_cap")

            if mint and MIN_MARKET_CAP <= market_cap <= MAX_MARKET_CAP and coin.get("telegram"):
                if mint not in seen_mints:
                    holders_info = fetch_token_holders(mint)
                    if not holders_info:
                        continue

                    dex_data = get_dex_data(mint)
                    if not dex_data:
                        continue

                    # Skip if any holder has more than 5%
                    large_holder_exists = any(
                        percentage > 5.0
                        for percentage in holders_info["top_5_percentages"])
                    if large_holder_exists:
                        continue

                    # Skip if top 5 holders have same rounded percentages
                    rounded_percentages = [
                        round(p, 1) for p in holders_info["top_5_percentages"]
                    ]
                    if len(set(rounded_percentages)) < len(rounded_percentages):
                        continue

                    # Check for bump bots and their history
                    if check_bump_bot_history(mint):
                        continue

                    new_coins.append((coin, holders_info, dex_data))
                    seen_mints[mint] = market_cap

        if new_coins:
            message = "🚀 <b>NEW COINS ALERT!</b> 🚀\n\n" + "\n".join(
                format_coin_message(coin, holders_info, dex_data)
                for coin, holders_info, dex_data in new_coins)

            # Use alternative bot credentials
            alt_url = f"https://api.telegram.org/bot7575928190:AAHaf-ujYaAhahmDAHkyLxuHZPPFnOc9E4Q/sendMessage"
            alt_payload = {
                "chat_id": "-1002352649464",
                "text": message,
                "parse_mode": "HTML",
                "disable_web_page_preview": True
            }
            try:
                response = requests.post(alt_url, json=alt_payload)
                response.raise_for_status()
            except requests.exceptions.RequestException as e:
                logging.error(f"Failed to send message to alt group: {e}")

        logging.info(f"Alt Scanner Checked: {len(new_coins)} new coins")
        await asyncio.sleep(15)

async def main():
    """Run both scanners concurrently."""
    await asyncio.gather(scan_coins(), scan_coins_alt())

def check_bump_bot_history(mint):
    """Placeholder function to check bump bot transaction history.  Replace with actual implementation."""
    # This is a placeholder; replace with your actual bump bot detection logic
    return False

if __name__ == "__main__":
    asyncio.run(main())